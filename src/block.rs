use chrono::prelude::*;
use sha2::{Sha256, Digest};
// use std::fmt;

// Struct representing a single Block in the blockchain
#[derive(Debug, Clone)]
pub struct Block {
    pub index: u32,           // Position of the block in the chain
    pub timestamp: String,    // When the block was created
    pub data: String,         // The data stored in the block (transactions)
    pub previous_hash: String, // Hash of the previous block in the chain
    pub hash: String,         // The block's own hash
    pub nonce: u64,           // Nonce used in proof-of-work to adjust hash
}

impl Block {
    // Create a new block
    pub fn new(index: u32, data: String, previous_hash: String) -> Block {
        let timestamp = Utc::now().to_string(); // Get current timestamp
        let mut block = Block {
            index,
            timestamp,
            data,
            previous_hash,
            hash: String::new(), // Empty for now, we'll calculate it next
            nonce: 0,            // Initial nonce set to 0
        };

        block.hash = block.calculate_hash(); // Calculate hash immediately
        block
    }

    // Calculate the block's hash using SHA-256
    /*
    A block's hash is like a digital fingerprint or a unique identifier for the contents of that block.
    - Hash Function: The hash is generated by passing the block’s contents (such as its data, timestamp, index, previous block's hash, and a special number called the nonce) through a cryptographic hash function (like SHA-256).
    - Unique: The result is a fixed-size string of characters (the "hash") that is unique to that specific block's contents. Even a small change in the block's contents will produce a completely different hash.
    - Immutable: Once a block’s hash is generated, it acts as proof of the block's data integrity. If anyone tries to change the block’s data, its hash will change, signaling that the block has been tampered with.
     */
    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        // Combine block fields into a string and hash them
        hasher.update(format!("{}{}{}{}{}", 
            self.index, self.timestamp, self.data, self.previous_hash, self.nonce));
        
        let result = hasher.finalize(); // Produce the hash
        format!("{:x}", result) // Convert hash to hex string
    }

    // Mine the block by making the miner solve a puzzle. In this case, find a valid hash with leading zeros.
    pub fn mine_block(&mut self, difficulty: usize) {
        let target = "0".repeat(difficulty); // Define target with 'difficulty' leading zeros
        
        // Increment the nonce until we find a hash that meets the target
        while self.hash[..difficulty] != target {
            self.nonce += 1;
            self.hash = self.calculate_hash(); // Recalculate hash after each nonce update
        }
        println!("Block mined: {}", self.hash);
    }
}
